import NextImage from "next/image";
import { Image } from "@mantine/core";
import BannerImage from "./banner.png";
import { Box, Paper, Title } from "@mantine/core";
import InlineVideo from "@/app/(blog)/blog/inline-video";
import BitclockImage from "./banner.png";

export const metadata = {
  // author: "Brady Law",
  // date: "2024-06-20",
  title: "Advanced ESP32 programming with ESP-IDF",
  description: "For projects that outgrow the Arduino SDK",
  // bannerImage: BannerImage,
  // tags: ["esp32", "esp-idf", "fimrware"]
};

{
// TODO:
// - Banner image
// - Facebook/Twitter share metadata
// - Post author, date, tags to page
// - Share buttons, Follow on X buttons
// - Code block filenames
// - Static analysis + code completion explanation
// - Interactive debugging explanation
// - Add Bitclock image somwehere
// - Blog navigation and list
}

<Title order={1} mt="xl">
  {metadata.title}
</Title>
<Title order={4} mt="sm" c="dimmed">
  {metadata.description}
</Title>

<Image
  component={NextImage}
  src={BitclockImage}
  w="100%"
  width={928}
  h={300}
  alt="Bitclock photo"
  radius="md"
  fit="cover"
  mt="md"
/>

<Paper shadow="xs" px="md" py="xs" mt="xl">
### Hobbyist electronics ❤️ ESP32

Many hobbyist electronics projects, such as [Bitclock](https://github.com/goat-hill/bitclock), use ESP32 modules to power their devices.

These SoC (system-on-a-chip) components are popular for a variety of reasons:

- **Simplicity**: Built-in Wi-Fi, Bluetooth, antenna and flash
- **Low price**: Modules for [~$1](https://www.digikey.com/en/products/detail/espressif-systems/ESP32-C3-MINI-1-N4/13877574), dev boards for [~$10](https://www.amazon.com/Seeed-Studio-XIAO-ESP32C3-Microcontroller/dp/B0B94JZ2YF/)
- **SDK**: Extensive development framework and high quality [documentation](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/index.html)
- **Low power consumption**: Can operate in the 10s of mA or sleep in µA
- **Pre-certification**: [Pre-certified](https://www.espressif.com/en/support/documents/certificates) by FCC and others so it's easier to sell

When developing firmware for these modules, many often start with the familiar Arduino SDK. However, as projects grow in complexity the Arduino ecosystem may no longer be the best choice.

In this post, I'll outline a more advanced firmware development setup using the Espressif **ESP-IDF SDK**, with **VSCode** as the IDE. This setup has worked well for the [Bitclock](https://github.com/goat-hill/bitclock) open-source project.

### Arduino vs ESP-IDF

#### Abstractions can add complexity

For a simple app like a blinking LED, the familiar Arduino SDK can be a fast and familiar way to get your project started. The SDK can (in theory) make your code hardware-agnostic. This is made possible through hardware-specific ports, and in the case of ESP32 devices, Espressif maintains the [arduino-esp32](https://github.com/espressif/arduino-esp32) port.

An alternative to using the Arduino SDK is to use the [ESP-IDF](https://github.com/espressif/esp-idf) framework, developed by Espressif specifically for their ESP32 chips. Notably, the [arduino-esp32](https://github.com/espressif/arduino-esp32) port
uses ESP-IDF under the hood to function and can be considered an abstraction on top of ESP-IDF.

Using the generic Arduino SDK abstraction layer brings both benefits and drawbacks:

- ✅ Code with a familiar SDK
- ✅ Better compatibility across different hardware
- ✅ Less effort to bootstrap
- ❌ Extra abstraction code = more complexity and bugs
- ❌ Abstract Arduino SDK cannot make ESP32 assumptions
- ❌ Less control over hardware, especially important given resource+power constraints

The ESP-IDF is still a high-level framework, and is extremely well [documented](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/index.html).

Some ESP-IDF [Bitclock](https://github.com/goat-hill/bitclock) could leverage include:

- [freertos](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/freertos.html) - Multi-threading for better display performance
- [ota](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/ota.html) - OTA firmware updates via Wi-Fi or bluetooth
- [partitions](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/partition-tables.html) - For custom layouts of flash memory
- [bt](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/bluetooth/index.html) - Bluetooth + BLE applications

The Bitclock project was already commited to using ESP32 modules, so there wasn't much benefit to using anything generic. As such, the decision was made to commit to the ESP-IDF framework.

#### Graduating from Arduino IDE

While it was decided that Bitclock would use ESP-IDF as opposed to Arduino, there was still a decision to make about the IDE.

VSCode was my preferred choice here. Why?

- Strong IDE support for C and C++ development
- Extremely performant
- Supports multiple files + directories way better then Arduino IDE
- Free
- Backed by Microsoft
- Integrates with Github Copilot which can [speed up development tasks](https://github.blog/2022-09-07-research-quantifying-github-copilots-impact-on-developer-productivity-and-happiness/)

That said, The Arduino IDE makes it very easy to boostrap and debug embedded projects. It was important for the Bitclock project to have a developer environment with equivalent functionality for:

1. **Simple build + run + serial log monitoring**
2. **Static analysis + code completion**
3. **Interactive GDB debugging**

It turns out this is all possible within VSCode, but does require a bit more setup work, which I will outline in the remainder of this post.

#### A note on PlatformIO

[PlatformIO](https://platformio.org/) is a popular project for ESP32 development within VSCode.

I first evaluated using that, but I did not find that it met the first requirement of _Minimize abstractions_. The VSCode extension it requires adds a lot of visual and functional bloat to the VSCode editor that I found unnecessary through the setup described later in this post.

### ESP-IDF toolchain setup

To start a project with ESP-IDF, you'll first need to install the ESP-IDF toolchain. Follow the [instructions on the Espressif website here](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/get-started/linux-macos-setup.html).

On macOS, you'll need create a directory to install the SDK to and the process goes something like this:

```sh
brew install cmake ninja dfu-util python@3.12 openssl
git clone -b v5.2.2 --recursive https://github.com/espressif/esp-idf.git
./install.fish esp32s3
source export.sh
```

Make sure to select the latest release version of ESP-IDF, the board you are using in place of `esp32s3` and read their docs for the latest instructions.

### Basic project setup

Create a separate new directory to house your project source code.

See the [ESP-IDF Hello World](https://github.com/espressif/esp-idf/tree/v5.2.2/examples/get-started/hello_world) example for the basic project setup.

The file structure will start with the following:

```text
├── CMakeLists.txt
├── pytest_hello_world.py      Python script used for automated testing
├── main
│   ├── CMakeLists.txt
│   └── hello_world_main.c
```

Once your project is created, and the ESP-IDF environment is active via `source ~/esp-idf/export.sh`, build and run is a simple via the CLI:

- `idf.py build`
- `idf.py flash`
- `idf.py monitor`

The [Hello World example](https://github.com/espressif/esp-idf/tree/v5.2.2/examples/get-started/hello_world) does a good job of giving the basics of how an ESP-IDF project is organized, so this post will focus on other topics.

### Static analysis + code completion

<InlineVideo
  src="/videos/vscode-completion.mp4"
  autoplay
  loop
  label="Auto-completion from ESP-IDF SDK"
/>

```json
{
  "env": {
    "esp-version": "esp-13.2.0_20230928"
  },
  "configurations": [
    {
      "name": "esp32s3",
      "compilerPath": "${HOME}/.espressif/tools/xtensa-esp-elf/${esp-version}/xtensa-esp-elf/bin/xtensa-esp-elf-gcc",
      "compileCommands": "${workspaceFolder}/build/compile_commands.json",
      "includePath": [
        "${HOME}/.espressif/tools/xtensa-esp-elf/${esp-version}/xtensa-esp-elf/xtensa-esp-elf/include/**",
        "${HOME}/code/esp-idf/components/**",
        "${workspaceFolder}/**"
      ],
      "browse": {
        "path": [
          "${HOME}/.espressif/tools/xtensa-esp-elf/${esp-version}/xtensa-esp-elf/xtensa-esp-elf/include/**",
          "${HOME}/code/esp-idf/components/**",
          "${workspaceFolder}/**"
        ],
        "limitSymbolsToIncludedHeaders": false
      },
      "defines": ["BOARD_TARGET=2"]
    }
  ],
  "version": 4
}
```

### Interactive debugging

<InlineVideo
  src="/videos/vscode-debug.mp4"
  autoplay
  loop
  label="GDB interactive debugging using OpenOCD"
/>

```sh
idf.py openocd
```

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "esp-openocd",
      "type": "cppdbg",
      "request": "launch",
      "program": "${workspaceFolder}/build/bitclock.elf",
      "MIMode": "gdb",
      "miDebuggerPath": "/Users/bradylaw/.espressif/tools/xtensa-esp-elf-gdb/12.1_20231023/xtensa-esp-elf-gdb/bin/xtensa-esp32s3-elf-gdb",
      "cwd": "${workspaceFolder}",
      "setupCommands": [
        { "text": "target extended-remote :3333" },
        { "text": "set remote hardware-watchpoint-limit 2" },
        { "text": "mon reset halt" },
        { "text": "maintenance flush register-cache" },
        { "text": "thb app_main" }
      ]
    }
  ]
}
```

Show how to attach in VSCode, set breakpoints, print values.

### Custom PCB design tips

Do not add a USB-to-UART, it is built-in to ESP32-S3 + ESP32-C3

Buttons are not required for switching to BOOT mode.

Don't forget strapping pins and pull-up resistors.

### Multi-target repo organization

```text
├── bitclock-fw/
│   ├── components/
│   ├── main/
│   ├── target-board-v1/
│   ├── target-board-v2/
│   ├── partitions.csv
│   └── sdkconfig.defaults
```

#### bitclock-fw/target-board-v2/

**Source files**

```text
├── .vscode/
│   ├── c_cpp_properties.json
│   ├── launch.json
│   └── settings.json
├── CMakeLists.txt
├── dependencies.lock
├── sdkconfig
```

**Symlinks**

```text
├── components/
├── main/
├── partitions.csv
```

**Auto-generated files**

```text
├── sdkconfig
├── dependencies.lock
```

### Parting thoughts

In this post, we outlined how to set up a development environment for an ESP32 project using ESP-IDF and VSCode instead of the more restrictive Arduino IDE.

In future posts we'll go into:

- Multi-threaded apps with freertos
- Working with e-ink displays and LVGL graphics
- Designing custom PCBs to fit 3D printed enclosures

In the meantime, send any comments or development tips to brady@bitclock.io!

Also if you're interested in a cute desk clock + air quality monitor for your desk that inspired this post, order one at [bitclock.io](https://bitclock.io).
It's completely open source and a fun hackable device to get started with ESP32 development.

</Paper>

by Brady Law

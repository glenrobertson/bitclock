import NextImage from "next/image";
import { Image } from "@mantine/core";
import BannerImage from "./banner.png";
import { Box, Paper, Title } from "@mantine/core";
import InlineVideo from "@/app/(blog)/blog/inline-video";
import InlineImage from "@/app/(blog)/blog/inline-image";
import BitclockImage from "./banner.png";
import PlatformioImage from "./platformio.png";

export const metadata = {
  // author: "Brady Law",
  // date: "2024-06-20",
  title: "Advanced ESP32 development with ESP-IDF",
  description: "For embedded projects that outgrow Arduino",
  // bannerImage: BannerImage,
  // tags: ["esp32", "esp-idf", "fimrware"]
};

{
// TODO:
// - Banner image
// - Facebook/Twitter share metadata
// - Post author, date, tags to page
// - Share buttons, Follow on X buttons
// - Code block filenames
// - Static analysis + code completion explanation
// - Interactive debugging explanation
// - Add Bitclock image somwehere
// - Blog navigation and list
}

<Title order={1} mt="xl">
  {metadata.title}
</Title>
<Title order={4} mt="sm" c="dimmed">
  {metadata.description}
</Title>

<Image
  component={NextImage}
  src={BitclockImage}
  w="100%"
  width={928}
  h={300}
  alt="Bitclock photo"
  radius="md"
  fit="cover"
  mt="md"
/>

<Paper shadow="xs" px="md" py="xs" mt="xl">
### Hobbyist electronics ❤️ ESP32

Many hobbyist electronics projects, including [Bitclock](https://github.com/goat-hill/bitclock), use ESP32 modules to power their devices.

These SoC (system-on-a-chip) components are popular for a variety of reasons:

- **Simplicity**: Built-in Wi-Fi, Bluetooth, antenna and flash
- **Low price**: Modules for [~$1](https://www.digikey.com/en/products/detail/espressif-systems/ESP32-C3-MINI-1-N4/13877574), dev boards for [~$10](https://www.amazon.com/Seeed-Studio-XIAO-ESP32C3-Microcontroller/dp/B0B94JZ2YF/)
- **SDK**: Extensive development framework and high quality [documentation](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/index.html)
- **Low power consumption**: Can operate in the 10s of mA or sleep in µA
- **Pre-certification**: [Pre-certified](https://www.espressif.com/en/support/documents/certificates) by FCC and others so it's easier to sell

When developing firmware for these modules, many start with the familiar Arduino SDK. However, as projects grow in complexity the Arduino ecosystem may no longer be the best choice.

In this post, I'll outline a more advanced firmware development setup using the Espressif **ESP-IDF SDK**, with **VSCode** as the IDE. This setup has worked well for the [Bitclock](https://github.com/goat-hill/bitclock) open-source project.

### Arduino vs ESP-IDF

#### Arduino abstraction adds complexity, limits control

For a simple embedded app like a blinking LED, the Arduino SDK is a popular way to bootstrap projects.
The generic SDK allows code to be hardware-agnostic, or at least partially.
This is made possible through hardware-specific ports known as **Arduino Cores**.

Each Arduino Core implements the core-level APIs of Arduino for their respective hardware platforms. In the case of ESP32 devices, Espressif
maintains the [arduino-esp32](https://github.com/espressif/arduino-esp32) core implementation.

An alternative to using the Arduino SDK is the [**ESP-IDF framework**](https://github.com/espressif/esp-idf), developed by Espressif specifically for their ESP32 chips.
Notably, the [arduino-esp32](https://github.com/espressif/arduino-esp32) core
uses ESP-IDF under the hood and is an abstraction layer on top.

So what's are the tradeoffs of using Arduino instead of ESP-IDF directly?

- ✅ Arduino is a familiar SDK
- ✅ Arduino is compatible with different hardware
- ✅ Arduino can be lower effort to bootstrap using the IDE
- ❌ Arduino core abstraction layer means more code, complexity, and room for bugs
- ❌ Arduino core APIs cannot make ESP32 assumptions, making hardware optimization more complex

For the Bitclock project, hardware cross-compatibility was not a priority. Instead, hardware _control_ was more important especially given the hardware constraints of:

- 400kB memory
- 8 MB flash
- Single core to multi-task display + sensors + networking

On the other hand, the ESP-IDF framework offers equivalent [high and low level APIs](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/index.html), and is very well documented.

Some of the ESP-IDF features Bitclock leverages include:

- [freertos](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/freertos.html) - Multi-threading for better display performance
- [ota](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/system/ota.html) - OTA firmware updates via Wi-Fi or bluetooth
- [partitions](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-guides/partition-tables.html) - For custom layouts of flash memory
- [bt](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/bluetooth/index.html) - Bluetooth + BLE applications

Given this, the decision was made to use ESP-IDF directly and bypass the Arduino abstraction.

#### Graduating from Arduino IDE to VSCode

With the SDK decision settled for Bitclock, there was an open question about the IDE choice.

Previous embedded projects I worked on used the Arduino IDE, but that no longer seemed the best option given the ESP-IDF choice. VSCode was the editor I use for most other programming projects, and has many appealing features:

- Strong IDE support for [C and C++ development](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools)
- Performant editor not bloated with features
- Better support for files and directories (as opposed to Arduino IDE)
- Free + corporate backing by Microsoft
- Integrates Github Copilot which can [speed up development](https://github.blog/2022-09-07-research-quantifying-github-copilots-impact-on-developer-productivity-and-happiness/)

In order to make the switch to VSCode, it was necessary to ensure that in VSCode I could keep a few core developer features of the Arduino IDE:

1. **Compile + flash + serial log monitoring**
2. **Static code analysis + code completion**
3. **Interactive GDB debugging**

It turns out this is all possible within VSCode, but does require a bit more setup work, which I will outline in the remainder of this post.

#### Evaluating PlatformIO

[PlatformIO](https://platformio.org/) is a popular VSCode extension for ESP32 development within VSCode.
While it is a functional solution for ESP-IDF development, I ultimately chose against using it.

My first impression after install that it felt like installing a bloated IDE within VSCode, as opposed to being a precise tool for the specific functionality needed like build + run + debug.

<InlineImage
  src={PlatformioImage}
  alt="PlatformIO screenshot"
  label="VSCode after PlatformIO extension installed"
/>

PlatformIO just felt a bit heavy-weight for my preference and perhaps triggered some past trauma of working with larger IDEs like Eclipse & Xcode.

Fortunately, there is an alternative way to get the functionality I desired using only VSCode, the [C/C++ extension by Microsoft](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools), and the [ESP-IDF](https://github.com/espressif/esp-idf) toolchain.

### ESP-IDF toolchain setup

In order to start developing with ESP-IDF, you'll first need to install the ESP-IDF toolchain. Follow the [instructions on the Espressif website here](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/get-started/linux-macos-setup.html).

On macOS, you'll need create a directory to install the SDK to and the process goes something like this:

```sh
brew install cmake ninja dfu-util python@3.12 openssl
git clone -b v5.2.2 --recursive https://github.com/espressif/esp-idf.git
./install.fish esp32s3
source export.sh
```

Make sure to select the latest release version of ESP-IDF, the board you are using in place of `esp32s3` and read their docs for the latest instructions.

### Basic project setup

Create a separate new directory to house your project source code.

See the [ESP-IDF Hello World](https://github.com/espressif/esp-idf/tree/v5.2.2/examples/get-started/hello_world) example for the basic project setup.

The file structure will start with the following:

```text
├── CMakeLists.txt
├── pytest_hello_world.py      Python script used for automated testing
├── main
│   ├── CMakeLists.txt
│   └── hello_world_main.c
```

Once your project is created, and the ESP-IDF environment is active via `source ~/esp-idf/export.sh`, build and run is a simple via the CLI:

- `idf.py build`
- `idf.py flash`
- `idf.py monitor`

The [Hello World example](https://github.com/espressif/esp-idf/tree/v5.2.2/examples/get-started/hello_world) does a good job of giving the basics of how an ESP-IDF project is organized, so this post will focus on other topics.

### Static analysis + code completion

<InlineVideo
  src="/videos/vscode-completion.mp4"
  autoplay
  loop
  label="Auto-completion from ESP-IDF SDK"
/>

```json
{
  "env": {
    "esp-version": "esp-13.2.0_20230928"
  },
  "configurations": [
    {
      "name": "esp32s3",
      "compilerPath": "${HOME}/.espressif/tools/xtensa-esp-elf/${esp-version}/xtensa-esp-elf/bin/xtensa-esp-elf-gcc",
      "compileCommands": "${workspaceFolder}/build/compile_commands.json",
      "includePath": [
        "${HOME}/.espressif/tools/xtensa-esp-elf/${esp-version}/xtensa-esp-elf/xtensa-esp-elf/include/**",
        "${HOME}/code/esp-idf/components/**",
        "${workspaceFolder}/**"
      ],
      "browse": {
        "path": [
          "${HOME}/.espressif/tools/xtensa-esp-elf/${esp-version}/xtensa-esp-elf/xtensa-esp-elf/include/**",
          "${HOME}/code/esp-idf/components/**",
          "${workspaceFolder}/**"
        ],
        "limitSymbolsToIncludedHeaders": false
      },
      "defines": ["BOARD_TARGET=2"]
    }
  ],
  "version": 4
}
```

### Interactive debugging

<InlineVideo
  src="/videos/vscode-debug.mp4"
  autoplay
  loop
  label="GDB interactive debugging using OpenOCD"
/>

```sh
idf.py openocd
```

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "esp-openocd",
      "type": "cppdbg",
      "request": "launch",
      "program": "${workspaceFolder}/build/bitclock.elf",
      "MIMode": "gdb",
      "miDebuggerPath": "/Users/bradylaw/.espressif/tools/xtensa-esp-elf-gdb/12.1_20231023/xtensa-esp-elf-gdb/bin/xtensa-esp32s3-elf-gdb",
      "cwd": "${workspaceFolder}",
      "setupCommands": [
        { "text": "target extended-remote :3333" },
        { "text": "set remote hardware-watchpoint-limit 2" },
        { "text": "mon reset halt" },
        { "text": "maintenance flush register-cache" },
        { "text": "thb app_main" }
      ]
    }
  ]
}
```

Show how to attach in VSCode, set breakpoints, print values.

### Custom PCB design tips

Do not add a USB-to-UART, it is built-in to ESP32-S3 + ESP32-C3

Buttons are not required for switching to BOOT mode.

Don't forget strapping pins and pull-up resistors.

### Multi-target repo organization

```text
├── bitclock-fw/
│   ├── components/
│   ├── main/
│   ├── target-board-v1/
│   ├── target-board-v2/
│   ├── partitions.csv
│   └── sdkconfig.defaults
```

#### bitclock-fw/target-board-v2/

**Source files**

```text
├── .vscode/
│   ├── c_cpp_properties.json
│   ├── launch.json
│   └── settings.json
├── CMakeLists.txt
├── dependencies.lock
├── sdkconfig
```

**Symlinks**

```text
├── components/
├── main/
├── partitions.csv
```

**Auto-generated files**

```text
├── sdkconfig
├── dependencies.lock
```

### Parting thoughts

In this post, we outlined how to set up a development environment for an ESP32 project using ESP-IDF and VSCode instead of the more restrictive Arduino IDE.

In future posts we'll go into:

- Multi-threaded apps with freertos
- Working with e-ink displays and LVGL graphics
- Designing custom PCBs to fit 3D printed enclosures

In the meantime, send any comments or development tips to brady@bitclock.io!

Also if you're interested in a cute desk clock + air quality monitor for your desk that inspired this post, order one at [bitclock.io](https://bitclock.io).
It's completely open source and a fun hackable device to get started with ESP32 development.

</Paper>

by Brady Law
